// Copyright 2016 Palantir Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package config

import (
	"encoding/json"
	"io/ioutil"
	"strings"

	"github.com/mitchellh/mapstructure"
	"github.com/palantir/pkg/matcher"
	"github.com/pkg/errors"
	"gopkg.in/yaml.v2"

	"github.com/palantir/godel/apps/distgo/pkg/osarch"
)

type ProjectConfig struct {
	Products          map[string]ProductConfig
	BuildOutputDir    string
	DistOutputDir     string
	DistScriptInclude string
	GroupID           string
	Exclude           matcher.Matcher
}

func (d ProjectConfig) FilteredProducts() map[string]ProductConfig {
	output := make(map[string]ProductConfig)
	for currProduct, currCfg := range d.Products {
		currMainPkg := currCfg.Build.MainPkg
		if !(d.Exclude != nil && d.Exclude.Match(currMainPkg)) {
			output[currProduct] = currCfg
		}
	}
	return output
}

type rawConfig struct {
	Products map[string]ProductConfig `yaml:"products" json:"products"` // map from product name to a product configuration object
	// BuildOutputDir specifies the default build output directory for products executables built by the "build"
	// command. The executables generated by "build" will be written to this directory unless the location is
	// overridden by the product-specific configuration.
	BuildOutputDir string `yaml:"build-output-dir" json:"build-output-dir"`
	// DistOutputDir specifies the default distribution output directory for product distributions created by the
	// "dist" command. The distribution directory and artifact generated by "dist" will be written to this directory
	// unless the location is overridden by the product-specific configuration.
	DistOutputDir string `yaml:"dist-output-dir" json:"dist-output-dir"`
	GroupID       string `yaml:"group-id" json:"group-id"` // identifier used as the group ID for the POM file.
	// DistScriptInclude is script content that is prepended to any non-empty ProductDistCfg.Script. It can be used
	// to define common functionality used in the distribution script for multiple different products.
	DistScriptInclude string                `yaml:"dist-script-include" json:"dist-script-include"`
	Exclude           matcher.NamesPathsCfg `yaml:"exclude" json:"exclude"` // names and paths to exclude when determining the projects to build
}

// ProductConfig represents user-specified configuration on how to build a specific product.
type ProductConfig struct {
	Build          BuildConfig   `yaml:"build" json:"build"`
	Run            RunConfig     `yaml:"run" json:"run"`
	Dist           DistConfigs   `yaml:"dist" json:"dist"`
	DefaultPublish PublishConfig `yaml:"publish" json:"publish"` // applies to dists that do not have their own PublishCfg.
}

type BuildConfig struct {
	// Script is the content of a script that is written to file a file and run before this product is built. The
	// contents of this value are written to a file with a header `#!/bin/bash` and executed. The script process
	// inherits the environment variables of the Go process and also has the following environment variables
	// defined:
	//
	//   PROJECT_DIR: the root directory of project
	//   PRODUCT: product name,
	//   VERSION: product version
	//   IS_SNAPSHOT: 1 if the version contains a git hash as part of the string, 0 otherwise
	Script string `yaml:"script" json:"script"`
	// MainPkg is the location of the main package for the product relative to the root directory. For example,
	// "./distgo/main".
	MainPkg string `yaml:"main-pkg" json:"main-pkg"`
	// OutputDir is the directory to which the executable is written.
	OutputDir string `yaml:"output-dir" json:"output-dir"`
	// BuildArgsScript is the content of a script that is written to a file and run before this product is built
	// to provide supplemental build arguments for the product. The contents of this value are written to a file
	// with a header `#!/bin/bash` and executed. The script process inherits the environment variables of the Go
	// process. Each line of output of the script is provided to the "build" command as a separate argument. For
	// example, the following script would add the arguments "-ldflags" "-X" "main.year=$YEAR" to the build command:
	//
	//   build-args-script: |
	//                      YEAR=$(date +%Y)
	//                      echo "-ldflags"
	//                      echo "-X"
	//                      echo "main.year=$YEAR"
	BuildArgsScript string `yaml:"build-args-script" json:"build-args-script"`
	// VersionVar is the path to a variable that is set with the version information for the build. For example,
	// "github.com/palantir/godel/cmd/godel.Version". If specified, it is provided to the "build" command as an
	// ldflag.
	VersionVar string `yaml:"version-var" json:"version-var"`
	// Environment specifies values for the environment variables that should be set for the build. For example,
	// the following sets CGO to false:
	//
	//   environment:
	//     CGO_ENABLED: "0"
	Environment map[string]string `yaml:"environment" json:"environment"`
	// OSArchs specifies the GOOS and GOARCH pairs for which the product is built. If blank, defaults to the GOOS
	// and GOARCH of the host system at runtime.
	OSArchs []osarch.OSArch `yaml:"os-archs" json:"os-archs"`
}

type DistConfigs []DistConfig

type DistConfig struct {
	OutputDir string `yaml:"output-dir" json:"output-dir"` // directory to which the distribution is written.
	// InputDir is the path (from the project root) to a directory whose contents will be copied into the output
	// distribution directory at the beginning of the "dist" command. Can be used to include static resources and
	// other files required in a distribution.
	InputDir string `yaml:"input-dir" json:"input-dir"`
	// InputProducts is a slice of the names of products in the project (other than the current one) whose binaries
	// are required for the "dist" task. The "dist" task will ensure that the outputs of "build" exist for all of
	// the products specified in this slice (and will build the products as part of the task if necessary) and make
	// the outputs available to the "dist" script as environment variables. Note that the "dist" task only
	// guarantees that the products will be built and their locations will be available in the environment variables
	// provided to the script -- it is the responsibility of the user to write logic in the dist script to copy the
	// generated binaries.
	InputProducts []string `yaml:"input-products" json:"input-products"`
	// Script is the content of a script that is written to file a file and run after the initial distribution
	// process but before the artifact generation process. The contents of this value are written to a file with a
	// header `#!/bin/bash` with the contents of the global `dist-script-include` prepended and executed. The script
	// process inherits the environment variables of the Go process and also has the following environment variables
	// defined:
	//
	//   DIST_DIR: the absolute path to the root directory of the distribution created for the current product
	//   PROJECT_DIR: the root directory of project
	//   PRODUCT: product name,
	//   VERSION: product version
	//   IS_SNAPSHOT: 1 if the version contains a git hash as part of the string, 0 otherwise
	Script string `yaml:"script" json:"script"`
	// Specifies the type of the distribution to be built and configuration for it. If unspecified, defaults to
	// a DistTypeConfig with DistType SLSDistType.
	DistType DistTypeConfig `yaml:"dist-type" json:"dist-type"`
	Publish  PublishConfig  `yaml:"publish" json:"publish"` // configuration for "publish" task.
}

type RunConfig struct {
	Args []string `yaml:"args" json:"args"` // arguments provided to the product when invoked using the "run" task.
}

type DistType string

const (
	SLSDistType DistType = "sls" // distribution that uses the Standard Layout Specification
	BinDistType DistType = "bin" // distribution that includes all of the binaries for a product
	RPMDistType DistType = "rpm" // RPM distribution
)

type DistTypeConfig struct {
	Type DistType    `yaml:"type" json:"type"`
	Info interface{} `yaml:"info" json:"info"`
}

type BinDistInfo struct {
	OmitInitSh         bool   `yaml:"omit-init-sh" json:"omit-init-sh"`                   // if true, omit "init.sh" file from distribution.
	InitShTemplateFile string `yaml:"init-sh-template-file" json:"init-sh-template-file"` // path to template to use for "init.sh" script.
}

type SLSDistInfo struct {
	// InitShTemplateFile is the path to a template file that is used as the basis for the init.sh script of the
	// distribution. The path is relative to the project root directory. The contents of the file is processed using
	// Go templates and is provided with a distgo.ProductBuildSpec struct. If omitted, the default init.sh script
	// is used.
	InitShTemplateFile string `yaml:"init-sh-template-file" json:"init-sh-template-file"`
	// ManifestTemplateFile is the path to a template file that is used as the basis for the manifest.yml file of
	// the distribution. The path is relative to the project root directory. The contents of the file is processed
	// using Go templates and is provided with a distgo.ProductBuildSpec struct.
	ManifestTemplateFile string                 `yaml:"manifest-template-file" json:"manifest-template-file"`
	ServiceArgs          string                 `yaml:"service-args" json:"service-args"`               // service arguments for the default init.sh file generated for the distribution.
	ProductType          string                 `yaml:"product-type" json:"product-type"`               // SLS product type for the distribution.
	ManifestExtensions   map[string]interface{} `yaml:"manifest-extensions" json:"manifest-extensions"` // SLS manifest extensions for the distribution.
	// YMLValidationExclude specifies a matcher used to specify YML files or paths that should not be validated as
	// part of creating the distribution. By default, the SLS distribution task verifies that all "*.yml" and
	// "*.yaml" files in the distribution are syntactically valid. If a distribution is known to ship with YML files
	// that are not valid YML, this parameter can be used to exclude those files from validation.
	YMLValidationExclude matcher.NamesPathsCfg `yaml:"yml-validation-exclude" json:"yml-validation-exclude"`
}

type RPMDistInfo struct {
	// Release is the release identifier that forms part of the name/version/release/architecture quadruplet
	// uniquely identifying the RPM package. Default is "1".
	Release string `yaml:"release" json:"release"`
	// ConfigFiles is a slice of absolute paths within the RPM that correspond to configuration files. RPM
	// identifies these as mutable. Default is no files.
	ConfigFiles         []string `yaml:"config-files" json:"config-files"`
	BeforeInstallScript string   `yaml:"before-install-script" json:"before-install-script"` // content of shell script to run before this RPM is installed. Optional.
	AfterInstallScript  string   `yaml:"after-install-script" json:"after-install-script"`   // content of shell script to run immediately after this RPM is installed. Optional.
	AfterRemoveScript   string   `yaml:"after-remove-script" json:"after-remove-script"`     // content of shell script to clean up after this RPM is removed. Optional.
}

type PublishConfig struct {
	GroupID string        `yaml:"group-id" json:"group-id"` // product-specific configuration equivalent to the global GroupID configuration.
	Almanac AlmanacConfig `yaml:"almanac" json:"almanac"`
}

type AlmanacConfig struct {
	Metadata map[string]string `yaml:"metadata" json:"metadata"` // metadata provided to the Almanac publish task
	Tags     []string          `yaml:"tags" json:"tags"`         // tags provided to the Almanac publish task
}

func (a *AlmanacConfig) empty() bool {
	return len(a.Metadata) == 0 && len(a.Tags) == 0
}

func Load(cfgPath, jsonContent string) (ProjectConfig, error) {
	var ymlContent string
	if cfgPath != "" {
		file, err := ioutil.ReadFile(cfgPath)
		if err != nil {
			return ProjectConfig{}, errors.Wrapf(err, "failed to read file %s", cfgPath)
		}
		ymlContent = string(file)
	}
	return LoadFromString(ymlContent, jsonContent)
}

func LoadFromString(ymlContent, jsonContent string) (ProjectConfig, error) {
	cfg := rawConfig{}
	if ymlContent != "" {
		if err := yaml.Unmarshal([]byte(ymlContent), &cfg); err != nil {
			return ProjectConfig{}, errors.Wrapf(err, "failed to unmarshal yml %s", ymlContent)
		}
	}

	// go through and convert DistCfgs.*.DistTypeCfg.Info objects to proper struct values based on
	// DistCfgs.*.DistTypeCfg.Type for each product config.
	for k, v := range cfg.Products {
		for i := range v.Dist {
			currDistTypeCfg := &v.Dist[i].DistType

			if currDistTypeCfg.Info != nil {
				convertMapKeysToCamelCase(currDistTypeCfg.Info)
				var decodeErr error
				switch currDistTypeCfg.Type {
				case SLSDistType:
					dstStruct := SLSDistInfo{}
					decodeErr = mapstructure.Decode(currDistTypeCfg.Info, &dstStruct)
					currDistTypeCfg.Info = dstStruct
					cfg.Products[k] = v
				case BinDistType:
					val := BinDistInfo{}
					decodeErr = mapstructure.Decode(currDistTypeCfg.Info, &val)
					currDistTypeCfg.Info = val
					cfg.Products[k] = v
				case RPMDistType:
					val := RPMDistInfo{}
					decodeErr = mapstructure.Decode(currDistTypeCfg.Info, &val)
					currDistTypeCfg.Info = val
					cfg.Products[k] = v
				default:
					return ProjectConfig{}, errors.Errorf("DistTypeCfgInfo for %v was %v, but no unmarshaller found for type %v", v, currDistTypeCfg.Info, currDistTypeCfg.Type)
				}

				if decodeErr != nil {
					return ProjectConfig{}, errors.Wrapf(decodeErr, "failed to unmarshal DistTypeCfg.Info for %v", v)
				}
			}
		}
	}

	if jsonContent != "" {
		jsonCfg := rawConfig{}
		if err := json.Unmarshal([]byte(jsonContent), &jsonCfg); err != nil {
			return ProjectConfig{}, err
		}
		cfg.Exclude.Add(jsonCfg.Exclude)
	}

	return ProjectConfig{
		Products:          cfg.Products,
		BuildOutputDir:    cfg.BuildOutputDir,
		DistOutputDir:     cfg.DistOutputDir,
		DistScriptInclude: cfg.DistScriptInclude,
		GroupID:           cfg.GroupID,
		Exclude:           cfg.Exclude.Matcher(),
	}, nil
}

func (out *DistConfigs) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var multiple []DistConfig
	if err := unmarshal(&multiple); err == nil {
		if len(multiple) == 0 {
			return errors.New("if `dist` key is specified, there must be at least one dist")
		}
		*out = multiple
		return nil
	}

	var single DistConfig
	if err := unmarshal(&single); err != nil {
		// return the error from a single DistConfig if neither one works
		return err
	}
	*out = []DistConfig{single}
	return nil
}

func (pub *PublishConfig) empty() bool {
	return pub.GroupID == "" && pub.Almanac.empty()
}

func convertMapKeysToCamelCase(input interface{}) {
	if inputMap, ok := input.(map[interface{}]interface{}); ok {
		for k, v := range inputMap {
			if str, ok := k.(string); ok {
				newStr := ""
				for _, currPart := range strings.Split(str, "-") {
					newStr += strings.ToUpper(currPart[0:1]) + currPart[1:]
				}
				delete(inputMap, k)
				inputMap[newStr] = v
			}
		}
	}
}
